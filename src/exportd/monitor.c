/*
  Copyright (c) 2010 Fizians SAS. <http://www.fizians.com>
  This file is part of Rozofs.

  Rozofs is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation, version 2.

  Rozofs is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/>.
 */
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <inttypes.h>

#include <rozofs/common/list.h>
#include <rozofs/common/log.h>
#include <rozofs/common/profile.h>
#include <rozofs/rpc/epproto.h>

#include "config.h"
#include "monitor.h"
#include "econfig.h"
#include "export_volume_stat.h"

DECLARE_PROFILING(epp_profiler_t);

#define HEADER "\
# This file was generated by exportd(8) version: %s.\n\
# All changes to this file will be lost.\n\n"


export_vol_stat_t *export_rebalance_vol_stat_p = NULL;
export_vol_cluster_stat2_t *export_rebalance_cluster_stat_p = NULL;

int monitor_initialize() {
    int status = -1;
    char path[FILENAME_MAX];
    DEBUG_FUNCTION;

    sprintf(path, "%s%s", DAEMON_PID_DIRECTORY, "exportd");
    if (access(path, X_OK) != 0) {
        if (mkdir(path, S_IRWXU) != 0) {
            severe("can't create %s", path);
            goto out;
        }
    }
    status = 0;
out:
    return status;
}

void monitor_release() {
    //XXX should clean MONITOR_DIRECTORY
    return;
}
/**
*  Update the statistics of the cluster

   @param cluster_idx : inde of the cluster in the structure
   @param cluster_id : cluster identifier
   @param nb_sid : number of sid in the cluster
   @param total_size: total size of the cluster in bytes
   @param free_size: cluster free size in bytes
   
   @retval none
*/
void export_rebalance_cluster_stats(int cluster_idx,uint16_t cluster_id,uint16_t nb_sid,uint64_t total_size_bytes,uint64_t free_size_bytes)
{
   if (export_rebalance_vol_stat_p == NULL) return;
   
   //info("FDL sizeof cluster file %u",sizeof(export_vol_cluster_stat2_t));
   if (cluster_idx>= ROZOFS_CLUSTERS_MAX) 
   {
      severe("cluster index is out of range %d (cid=%d)",cluster_idx,cluster_id);
      return;
   }   
   export_vol_cluster_stat_t *p;
   
   p = &export_rebalance_vol_stat_p->cluster_tab[cluster_idx];
   p->cluster_id = cluster_id;
   p->nb_sid = nb_sid;
   p->total_size_bytes = total_size_bytes;
   p->free_size_bytes = free_size_bytes;
   if (total_size_bytes!= 0) p->free_percent =free_size_bytes*100/total_size_bytes;
}  

/**
*  Update the statistics of sid within a  cluster

   @param storage_idx : inde of the sid in the structure
   @param storage_id : storage identifier
   @param status : storage status
   @param host : storage hostname
   @param total_size: total size of the storage in bytes
   @param free_size: storage free size in bytes
   
   @retval none
*/
void export_rebalance_cluster_sid_stats(int storage_idx,uint16_t storage_id,uint8_t status,char *host,
                                	uint64_t total_size_bytes,
					uint64_t free_size_bytes)
{
   if (export_rebalance_cluster_stat_p == NULL) return;
   if (storage_idx>= SID_MAX) 
   {
      severe("sid index is out of range %d (sid=%d)",storage_idx,storage_id);
      return;
   }   
   export_vol_sid_in_cluster_t *p;
   
   p = &export_rebalance_cluster_stat_p->sid_tab[storage_idx];
   p->sid = storage_id;
   p->state = status;
   strcpy((char *)p->hostname,host);
   p->total_size_bytes = total_size_bytes;
   p->free_size_bytes = free_size_bytes;
   if (total_size_bytes!= 0) p->free_percent =free_size_bytes*100/total_size_bytes;

}  



int monitor_volume(volume_t *volume) {
    int status = -1;
    int fd = -1;
    int fd_v = -1;
    char path[FILENAME_MAX];
    volume_stat_t vstat;
    list_t *p, *q;
    volume_t clone;
    uint32_t nb_storages = 0;
    int nb_cluster_in_volume = 0;
    int nb_sid_in_cluster = 0;
    int cluster_idx = 0;
    int storage_idx = 0;
    int local_site = export_get_local_site_number();
    ssize_t written_size;
    
    if (export_rebalance_vol_stat_p == NULL)
    {
      export_rebalance_vol_stat_p = malloc(sizeof(export_vol_stat_t));
      if (export_rebalance_vol_stat_p == NULL)
      {
        severe("out of memory while allocation %lu bytes",sizeof(export_vol_stat_t));
      }
    }
    if (export_rebalance_vol_stat_p != NULL) memset(export_rebalance_vol_stat_p,0,sizeof(export_vol_stat_t));

    if (export_rebalance_cluster_stat_p == NULL)
    {
      export_rebalance_cluster_stat_p = malloc(sizeof(export_vol_cluster_stat2_t));
      if (export_rebalance_cluster_stat_p == NULL)
      {
        severe("out of memory while allocation %lu bytes",sizeof(export_vol_cluster_stat2_t));
      }
    }


    volume_initialize(&clone, 0, 0, 0, 0);
    if (volume_safe_copy(&clone, volume) != 0) {
        severe("can't clone volume: %d", volume->vid);
        goto out;
    }

    sprintf(path, "%s%s%d", DAEMON_PID_DIRECTORY, "exportd/volume_", clone.vid);
    if ((fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU | S_IROTH)) < 0) {
        severe("can't open %s", path);
        goto out;
    }

    gprofiler.vstats[gprofiler.nb_volumes].vid = clone.vid;
    gprofiler.vstats[gprofiler.nb_volumes].georep = clone.georep;

    dprintf(fd, HEADER, VERSION);
    dprintf(fd, "volume: %u\n", clone.vid);
    dprintf(fd, "  georep: %s\n", clone.georep?"YES":"NO");
    dprintf(fd, "  multi site: %s\n", clone.multi_site?"YES":"NO");

    //XXX TO CHANGE
    volume_stat(&clone,&vstat);
    gprofiler.vstats[gprofiler.nb_volumes].bsize = vstat.bsize;
    gprofiler.vstats[gprofiler.nb_volumes].bfree = vstat.bfree;
    gprofiler.vstats[gprofiler.nb_volumes].blocks = vstat.blocks;

    dprintf(fd, "  bsize: %u\n", vstat.bsize);
    dprintf(fd, "  bfree: %"PRIu64"\n", vstat.bfree);
    dprintf(fd, "  blocks: %"PRIu64"\n", vstat.blocks);
    if (vstat.blocks == 0) {
      dprintf(fd, "  %cfree: 0\n",'%');
    }
    else {
      dprintf(fd, "  %cfree: %"PRIu64"\n", '%', vstat.bfree*100/vstat.blocks);
    }
    nb_cluster_in_volume = list_size(&clone.clusters);
    dprintf(fd, "  nb_clusters: %d\n", nb_cluster_in_volume);
    if  (export_rebalance_vol_stat_p != NULL)   
    {
      export_rebalance_vol_stat_p->volume_id = clone.vid;
      export_rebalance_vol_stat_p->nb_cluster = nb_cluster_in_volume;
       
    } 
    list_for_each_forward(p, &clone.clusters) {
        cluster_t *cluster = list_entry(p, cluster_t, list);
	nb_sid_in_cluster = list_size((&cluster->storages[local_site]));
        dprintf(fd, "    cluster: %u\n", cluster->cid);
        dprintf(fd, "      nb_storages: %d\n", nb_sid_in_cluster);
        dprintf(fd, "      size: %"PRIu64"\n", cluster->size);
        dprintf(fd, "      free: %"PRIu64"\n", cluster->free);
	if (cluster->size==0) {
          dprintf(fd, "      %cfree: 0\n",'%');	   
	}
	else {
          dprintf(fd, "      %cfree: %"PRIu64"\n",'%', cluster->free*100/cluster->size);     
	}
	export_rebalance_cluster_stats(cluster_idx,cluster->cid,nb_sid_in_cluster,cluster->size,cluster->free);  
	cluster_idx++; 
	
	if (clone.georep) {
	  dprintf(fd, "        site: %d\n", local_site); 
	}
	storage_idx = 0;
	if (export_rebalance_cluster_stat_p != NULL) 
	{
	   memset(export_rebalance_cluster_stat_p,0,sizeof(export_vol_cluster_stat2_t));
	   export_rebalance_cluster_stat_p->cluster_id = cluster->cid;
	   export_rebalance_cluster_stat_p->nb_sid = nb_sid_in_cluster;
	   export_rebalance_cluster_stat_p->total_size_bytes = cluster->size;
	   export_rebalance_cluster_stat_p->free_size_bytes = cluster->free;	   
	}
        list_for_each_forward(q, (&cluster->storages[local_site])) {
            volume_storage_t *storage = list_entry(q, volume_storage_t, list);

            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].cid = cluster->cid;
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].sid = storage->sid;
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].status = storage->status;
	    strcpy(gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].host,storage->host);
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].size = storage->stat.size;
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].free = storage->stat.free;
	    export_rebalance_cluster_sid_stats(storage_idx,
	                                       storage->sid,
		                               storage->status,storage->host,
					       storage->stat.size,storage->stat.free);  
	    storage_idx++;

	    if (clone.georep) 
	      gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].site = local_site;
	    else  
	      gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].site = storage->siteNum;
            nb_storages++;

            dprintf(fd, "          storage: %u\n", storage->sid);
	    dprintf(fd, "            host: %s\n", storage->host);
	    if (clone.multi_site) {
            dprintf(fd, "            site: %d\n", storage->siteNum);
	    }  
            dprintf(fd, "            status: %s\n", (storage->status==1)?"UP":"DOWN");
            dprintf(fd, "            size: %"PRIu64"\n", storage->stat.size);
            dprintf(fd, "            free: %"PRIu64"\n", storage->stat.free);
	    if (storage->stat.size==0) {
              dprintf(fd, "            %cfree: 0\n",'%');	   
	    }
	    else {
              dprintf(fd, "            %cfree: %"PRIu64"\n",'%', storage->stat.free*100/storage->stat.size);	   
	    }   
        }
	/*
	** write the cluster information on disk for rebalance process
	*/
	if (export_rebalance_cluster_stat_p != NULL)
	{
	  fd_v = -1;
	  while(1)
	  {
	    sprintf(path, "%s%s%d_cluster_%d.bin", DAEMON_PID_DIRECTORY, "exportd/volume_", clone.vid,cluster->cid);
	    if ((fd_v = open(path, O_WRONLY | O_CREAT , S_IRWXU | S_IROTH)) < 0) {
        	severe("can't open %s", path);
        	break;
	    } 
	    written_size = pwrite(fd_v,(const void *)export_rebalance_cluster_stat_p,sizeof(export_vol_cluster_stat2_t),0);
	    if ( written_size < 0)
	    {
               severe("write error for %s: %s",path,strerror(errno));
	       break;
	    }
	    break;
	  }
	  if (fd_v != -1) close (fd_v);    
	}
	
	if (clone.georep) {
	  dprintf(fd, "        site: %d\n", 1-local_site); 
          list_for_each_forward(q, (&cluster->storages[1-local_site])) {
              volume_storage_t *storage = list_entry(q, volume_storage_t, list);

              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].cid = cluster->cid;
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].sid = storage->sid;
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].status = storage->status;
	      strcpy(gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].host,storage->host);
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].size = storage->stat.size;
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].free = storage->stat.free;
	      gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].site = 1-local_site;
              nb_storages++;

              dprintf(fd, "          storage: %u\n", storage->sid);
	      dprintf(fd, "            host: %s\n", storage->host);
	      if (clone.multi_site) {
              dprintf(fd, "            site: %d\n", storage->siteNum);
	      }  
              dprintf(fd, "            status: %s\n", (storage->status==1)?"UP":"DOWN");
              dprintf(fd, "            size: %"PRIu64"\n", storage->stat.size);
              dprintf(fd, "            free: %"PRIu64"\n", storage->stat.free);
	      if (storage->stat.size==0) {
        	dprintf(fd, "            %cfree: 0\n",'%');	   
	      }
	      else {
        	dprintf(fd, "            %cfree: %"PRIu64"\n",'%', storage->stat.free*100/storage->stat.size);	   
	      }   
          }
	}  
    }
    /*
    ** write the volume information on disk for rebalance process
    */
    if (export_rebalance_vol_stat_p != NULL)
    {
      fd_v = -1;
      while(1)
      {
	sprintf(path, "%s%s%d.bin", DAEMON_PID_DIRECTORY, "exportd/volume_", clone.vid);
	if ((fd_v = open(path, O_WRONLY | O_CREAT , S_IRWXU | S_IROTH)) < 0) {
            severe("can't open %s", path);
            break;
	} 
	written_size = pwrite(fd_v,(const void *)export_rebalance_vol_stat_p,sizeof(export_vol_stat_t),0);
	if ( written_size < 0)
	{
           severe("write error for %s: %s",path,strerror(errno));
	   break;
	}
	break;
      }
      if (fd_v != -1) close (fd_v);    
    }
    
    gprofiler.vstats[gprofiler.nb_volumes].nb_storages = nb_storages;
 
    

    // Free the clone volume
    p = NULL;
    q = NULL;

    list_for_each_forward_safe(p, q, &clone.clusters) {
        cluster_t *entry = list_entry(p, cluster_t, list);
        list_remove(p);
        cluster_release(entry);
        free(entry);
    }

    status = 0;
out:
    if (fd > 0) close(fd);
    return status;
}
int monitor_volume_slave(volume_t *volume) {
    int status = -1;
    volume_stat_t vstat;
    list_t *p, *q;
    volume_t clone;
    uint32_t nb_storages = 0;
    int local_site = export_get_local_site_number();

    volume_initialize(&clone, 0, 0,0,0);
    if (volume_safe_copy(&clone, volume) != 0) {
        severe("can't clone volume: %d", volume->vid);
        goto out;
    }

    gprofiler.vstats[gprofiler.nb_volumes].vid = clone.vid;
    gprofiler.vstats[gprofiler.nb_volumes].georep = clone.georep;


    //XXX TO CHANGE
    volume_stat(&clone,&vstat);
    gprofiler.vstats[gprofiler.nb_volumes].bsize = vstat.bsize;
    gprofiler.vstats[gprofiler.nb_volumes].bfree = vstat.bfree;
    gprofiler.vstats[gprofiler.nb_volumes].blocks = vstat.blocks;

    list_for_each_forward(p, &clone.clusters) {
        cluster_t *cluster = list_entry(p, cluster_t, list);
     list_for_each_forward(q, (&cluster->storages[local_site])) {
            volume_storage_t *storage = list_entry(q, volume_storage_t, list);

            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].cid = cluster->cid;
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].sid = storage->sid;
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].status = storage->status;
	    strcpy(gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].host,storage->host);
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].size = storage->stat.size;
            gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].free = storage->stat.free;
	    if (clone.georep) 
	      gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].site = local_site;
	    else  
	      gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].site = storage->siteNum;
            nb_storages++;
        }
	
	if (clone.georep) {
          list_for_each_forward(q, (&cluster->storages[1-local_site])) {
              volume_storage_t *storage = list_entry(q, volume_storage_t, list);

              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].cid = cluster->cid;
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].sid = storage->sid;
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].status = storage->status;
	      strcpy(gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].host,storage->host);
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].size = storage->stat.size;
              gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].free = storage->stat.free;
	      gprofiler.vstats[gprofiler.nb_volumes].sstats[nb_storages].site = 1-local_site;
              nb_storages++;
          }
	}  
    }
    
    gprofiler.vstats[gprofiler.nb_volumes].nb_storages = nb_storages;
    

    // Free the clone volume
    p = NULL;
    q = NULL;

    list_for_each_forward_safe(p, q, &clone.clusters) {
        cluster_t *entry = list_entry(p, cluster_t, list);
        list_remove(p);
        cluster_release(entry);
        free(entry);
    }

    status = 0;
out:
    return status;
}
int monitor_export(export_t *export) {
    int status = -1;
    int fd = -1;
    char path[FILENAME_MAX];
    ep_statfs_t estat;
    uint64_t exceed = 0;
    DEBUG_FUNCTION;

    sprintf(path, "%s%s%d", DAEMON_PID_DIRECTORY, "exportd/export_", export->eid);
    if ((fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU | S_IROTH)) < 0) {
        severe("can't open %s", path);
        goto out;
    }

    if (export_stat(export, &estat) != 0) {
        severe("can't stat export: %"PRIu32"", export->eid);
        goto out;
    }

    gprofiler.estats[gprofiler.nb_exports].eid = export->eid;
    strcpy(gprofiler.estats[gprofiler.nb_exports].path, export->root);
    gprofiler.estats[gprofiler.nb_exports].vid = export->volume->vid;
    gprofiler.estats[gprofiler.nb_exports].bsize = estat.bsize;
    gprofiler.estats[gprofiler.nb_exports].blocks = estat.blocks;
    gprofiler.estats[gprofiler.nb_exports].bfree = estat.bfree;
    gprofiler.estats[gprofiler.nb_exports].files = estat.files;
    gprofiler.estats[gprofiler.nb_exports].ffree = estat.ffree;

    dprintf(fd, HEADER, VERSION);
    dprintf(fd, "export: %"PRIu32"\n", export->eid);
    dprintf(fd, "volume: %u\n", export->volume->vid);
    dprintf(fd, "root: %s\n", export->root);
    dprintf(fd, "squota: %"PRIu64"\n", export->squota);
    dprintf(fd, "hquota: %"PRIu64"\n", export->hquota);
    dprintf(fd, "bsize: %u\n", estat.bsize);
    dprintf(fd, "blocks: %"PRIu64"\n", estat.blocks);
    dprintf(fd, "bfree: %"PRIu64"\n", estat.bfree);
    dprintf(fd, "files: %"PRIu64"\n", estat.files);
    dprintf(fd, "ffree: %"PRIu64"\n", estat.ffree);
    if (export->squota > 0) {
        exceed = estat.blocks - estat.bfree > export->squota ?
                estat.blocks - estat.bfree - export->squota : 0;
    }
    dprintf(fd, "squota_exceed: %"PRIu64"\n", exceed);

    status = 0;
out:
    if (fd > 0) close(fd);
    return status;
}
